'use client';

import { useMemo, useCallback } from 'react';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { Program, AnchorProvider, web3, BN } from '@coral-xyz/anchor';
import { PublicKey, SystemProgram, SYSVAR_RENT_PUBKEY } from '@solana/web3.js';
import { Dare, Bet, CreateDareParams, PlaceBetParams, SubmitProofParams, BetType, CashOutParams } from '@/types';
import toast from 'react-hot-toast';

// Import the IDL (this would be generated by Anchor)
import idl from '@/lib/idl.json';

const PROGRAM_ID = new PublicKey('11111111111111111111111111111111'); // Placeholder - replace with actual program ID after deployment

export const useDareProgram = () => {
  const { connection } = useConnection();
  const { publicKey, signTransaction, signAllTransactions } = useWallet();

  const provider = useMemo(() => {
    if (!publicKey || !signTransaction || !signAllTransactions) {
      return null;
    }

    return new AnchorProvider(
      connection,
      {
        publicKey,
        signTransaction,
        signAllTransactions,
      },
      AnchorProvider.defaultOptions()
    );
  }, [connection, publicKey, signTransaction, signAllTransactions]);

  const program = useMemo(() => {
    if (!provider) return null;
    return new Program(idl as any, PROGRAM_ID, provider);
  }, [provider]);

  const getDares = useCallback(async (): Promise<Dare[]> => {
    if (!program) {
      console.log('[useDareProgram] No program available');
      return [];
    }

    try {
      console.log('[useDareProgram] Fetching dares from program...');
      
      // Add timeout to prevent hanging
      const timeoutPromise = new Promise<Dare[]>((_, reject) => 
        setTimeout(() => reject(new Error('Timeout fetching dares')), 5000)
      );
      
      const fetchPromise = program.account.dare.all();
      
      const accounts = await Promise.race([fetchPromise, timeoutPromise]) as any[];
      console.log('[useDareProgram] Fetched accounts:', accounts.length);
      return accounts as Dare[];
    } catch (error: any) {
      console.error('[useDareProgram] Error fetching dares:', error.message || error);
      return [];
    }
  }, [program]);

  const fetchDare = useCallback(async (darePublicKey: PublicKey): Promise<Dare | null> => {
    if (!program) return null;

    try {
      const account = await program.account.dare.fetch(darePublicKey);
      return {
        publicKey: darePublicKey,
        account,
      } as Dare;
    } catch (error) {
      console.error('Error fetching dare:', error);
      return null;
    }
  }, [program]);

  const getUserBets = useCallback(async (userPublicKey: PublicKey): Promise<Bet[]> => {
    if (!program) return [];

    try {
      const accounts = await program.account.bet.all([
        {
          memcmp: {
            offset: 8 + 32, // discriminator + dare pubkey
            bytes: userPublicKey.toBase58(),
          },
        },
      ]);
      return accounts as Bet[];
    } catch (error) {
      console.error('Error fetching user bets:', error);
      return [];
    }
  }, [program]);

  const createDare = async (params: CreateDareParams): Promise<boolean> => {
    if (!program || !publicKey) {
      toast.error('Wallet not connected');
      return false;
    }

    try {
      const [darePublicKey] = PublicKey.findProgramAddressSync(
        [Buffer.from('dare'), publicKey.toBuffer(), Buffer.from(params.title)],
        PROGRAM_ID
      );

      const [poolAccount] = PublicKey.findProgramAddressSync(
        [Buffer.from('pool'), darePublicKey.toBuffer()],
        PROGRAM_ID
      );

      const tx = await program.methods
        .createDare(
          params.title,
          params.description,
          new BN(params.deadline),
          new BN(params.minBet),
          publicKey // platform_authority - for now same as creator
        )
        .accounts({
          dare: darePublicKey,
          poolAccount,
          creator: publicKey,
          systemProgram: SystemProgram.programId,
          rent: SYSVAR_RENT_PUBKEY,
        })
        .rpc();

      // Save additional metadata to database
      try {
        await fetch('/api/dares', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            onChainId: darePublicKey.toString(),
            title: params.title,
            description: params.description,
            creator: publicKey.toString(),
            logoUrl: params.logoUrl,
            bannerUrl: params.bannerUrl,
            deadline: new Date(params.deadline * 1000).toISOString(),
            minBet: params.minBet / 1e9, // Convert back to SOL for database
          }),
        });
      } catch (dbError) {
        console.error('Failed to save dare metadata to database:', dbError);
        // Don't fail the entire operation if database save fails
      }

      toast.success('Dare created successfully!');
      return true;
    } catch (error) {
      console.error('Error creating dare:', error);
      toast.error('Failed to create dare');
      return false;
    }
  };

  const placeBet = async (params: PlaceBetParams): Promise<boolean> => {
    if (!program || !publicKey) {
      toast.error('Wallet not connected');
      return false;
    }

    try {
      const [betPublicKey] = PublicKey.findProgramAddressSync(
        [Buffer.from('bet'), params.darePublicKey.toBuffer(), publicKey.toBuffer()],
        PROGRAM_ID
      );

      const [poolAccount] = PublicKey.findProgramAddressSync(
        [Buffer.from('pool'), params.darePublicKey.toBuffer()],
        PROGRAM_ID
      );

      const betTypeValue = params.betType === BetType.WillDo ? { willDo: {} } : { wontDo: {} };

      const tx = await program.methods
        .placeBet(new BN(params.amount), betTypeValue)
        .accounts({
          dare: params.darePublicKey,
          bet: betPublicKey,
          poolAccount,
          bettor: publicKey,
          systemProgram: SystemProgram.programId,
        })
        .rpc();

      toast.success('Bet placed successfully!');
      return true;
    } catch (error) {
      console.error('Error placing bet:', error);
      toast.error('Failed to place bet');
      return false;
    }
  };

  const submitProof = async (params: SubmitProofParams): Promise<boolean> => {
    if (!program || !publicKey) {
      toast.error('Wallet not connected');
      return false;
    }

    try {
      const tx = await program.methods
        .submitProof(params.proofHash, params.proofDescription)
        .accounts({
          dare: params.darePublicKey,
          submitter: publicKey,
        })
        .rpc();

      toast.success('Proof submitted successfully!');
      return true;
    } catch (error) {
      console.error('Error submitting proof:', error);
      toast.error('Failed to submit proof');
      return false;
    }
  };

  const claimWinnings = async (darePublicKey: PublicKey): Promise<boolean> => {
    if (!program || !publicKey) {
      toast.error('Wallet not connected');
      return false;
    }

    try {
      const [betPublicKey] = PublicKey.findProgramAddressSync(
        [Buffer.from('bet'), darePublicKey.toBuffer(), publicKey.toBuffer()],
        PROGRAM_ID
      );

      const [poolAccount] = PublicKey.findProgramAddressSync(
        [Buffer.from('pool'), darePublicKey.toBuffer()],
        PROGRAM_ID
      );

      const tx = await program.methods
        .claimWinnings()
        .accounts({
          dare: darePublicKey,
          bet: betPublicKey,
          poolAccount,
          winner: publicKey,
          systemProgram: SystemProgram.programId,
        })
        .rpc();

      toast.success('Winnings claimed successfully!');
      return true;
    } catch (error) {
      console.error('Error claiming winnings:', error);
      toast.error('Failed to claim winnings');
      return false;
    }
  };

  const claimCompletionReward = async (darePublicKey: PublicKey): Promise<boolean> => {
    if (!program || !publicKey) {
      toast.error('Wallet not connected');
      return false;
    }

    try {
      const [poolAccount] = PublicKey.findProgramAddressSync(
        [Buffer.from('pool'), darePublicKey.toBuffer()],
        PROGRAM_ID
      );

      const tx = await program.methods
        .claimCompletionReward()
        .accounts({
          dare: darePublicKey,
          poolAccount,
          submitter: publicKey,
          systemProgram: SystemProgram.programId,
        })
        .rpc();

      toast.success('Completion reward claimed successfully!');
      return true;
    } catch (error) {
      console.error('Error claiming completion reward:', error);
      toast.error('Failed to claim completion reward');
      return false;
    }
  };

  const cashOutEarly = async (params: CashOutParams): Promise<boolean> => {
    if (!program || !publicKey) {
      toast.error('Wallet not connected');
      return false;
    }

    try {
      const [betPublicKey] = PublicKey.findProgramAddressSync(
        [Buffer.from('bet'), params.darePublicKey.toBuffer(), publicKey.toBuffer()],
        PROGRAM_ID
      );

      const [poolAccount] = PublicKey.findProgramAddressSync(
        [Buffer.from('pool'), params.darePublicKey.toBuffer()],
        PROGRAM_ID
      );

      const tx = await program.methods
        .cashOutEarly()
        .accounts({
          dare: params.darePublicKey,
          bet: betPublicKey,
          poolAccount,
          bettor: publicKey,
          systemProgram: SystemProgram.programId,
        })
        .rpc();

      toast.success('Cashed out successfully! (10% penalty applied)');
      return true;
    } catch (error: any) {
      console.error('Error cashing out:', error);
      if (error.message?.includes('CashOutTooLate')) {
        toast.error('Cannot cash out within 10 minutes of deadline');
      } else {
        toast.error('Failed to cash out');
      }
      return false;
    }
  };

  const claimCreatorFee = async (darePublicKey: PublicKey): Promise<boolean> => {
    if (!program || !publicKey) {
      toast.error('Wallet not connected');
      return false;
    }

    try {
      const [poolAccount] = PublicKey.findProgramAddressSync(
        [Buffer.from('pool'), darePublicKey.toBuffer()],
        PROGRAM_ID
      );

      const tx = await program.methods
        .claimCreatorFee()
        .accounts({
          dare: darePublicKey,
          poolAccount,
          creator: publicKey,
          systemProgram: SystemProgram.programId,
        })
        .rpc();

      toast.success('Creator fee claimed successfully!');
      return true;
    } catch (error) {
      console.error('Error claiming creator fee:', error);
      toast.error('Failed to claim creator fee');
      return false;
    }
  };

  const approveProof = async (darePublicKey: PublicKey, approve: boolean): Promise<boolean> => {
    if (!program || !publicKey) {
      toast.error('Wallet not connected');
      return false;
    }

    try {
      const tx = await program.methods
        .approveProof(approve)
        .accounts({
          dare: darePublicKey,
          platformAuthority: publicKey,
        })
        .rpc();

      toast.success(`Proof ${approve ? 'approved' : 'rejected'} successfully!`);
      return true;
    } catch (error) {
      console.error('Error approving proof:', error);
      toast.error('Failed to approve proof');
      return false;
    }
  };

  return {
    program,
    getDares,
    fetchDare,
    getUserBets,
    createDare,
    placeBet,
    submitProof,
    claimWinnings,
    claimCompletionReward,
    claimCreatorFee,
    cashOutEarly,
    approveProof,
  };
};